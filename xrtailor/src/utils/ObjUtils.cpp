#include <xrtailor/runtime/mesh/Mesh.hpp>
#include <xrtailor/utils/ObjUtils.hpp>

namespace XRTailor {
template <class ModelConfig>
void SaveBodyAsObj(const std::string& path, std::shared_ptr<smplx::Body<ModelConfig>> body,
                   std::shared_ptr<PhysicsMesh> physics_mesh) {
  thrust::host_vector<Vector3> h_positions = physics_mesh->HostPositions();
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o smplx\n";
  for (size_t i = 0; i < body->model.n_verts(); i++) {
    Vector3 pos = h_positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < body->model.n_faces(); ++i) {
    ofs << "f " << body->model.faces(i, 0) + 1 << " " << body->model.faces(i, 1) + 1 << " "
        << body->model.faces(i, 2) + 1 << "\n";
  }
  ofs.close();
}

void SaveBodyAsObjDebug(const std::string& path, std::shared_ptr<PhysicsMesh> physics_mesh) {
  thrust::host_vector<Vector3> h_positions = physics_mesh->HostPositions();
  thrust::host_vector<uint> h_indices = physics_mesh->HostIndices();
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o smplx\n";
  for (size_t i = 0; i < physics_mesh->NumNodes(); i++) {
    Vector3 pos = h_positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < h_indices.size() / 3; ++i) {
    ofs << "f " << h_indices[i * 3] + 1 << " " << h_indices[i * 3 + 1] + 1 << " "
        << h_indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

template <class ModelConfig>
void SaveBodyAsObj(const std::string& path, std::shared_ptr<smplx::Body<ModelConfig>> body,
                   Vector3* h_positions) {
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o smplx\n";
  for (size_t i = 0; i < body->model.n_verts(); i++) {
    Vector3 pos = h_positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < body->model.n_faces(); ++i) {
    ofs << "f " << body->model.faces(i, 0) + 1 << " " << body->model.faces(i, 1) + 1 << " "
        << body->model.faces(i, 2) + 1 << "\n";
  }
  ofs.close();
}

void SaveGarmentAsObj(const std::string& path, std::shared_ptr<PhysicsMesh> physics_mesh) {
  std::cout << "Save garment obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o garment\n";
  int num_vertices = physics_mesh->nodes.size();
  int num_triangles = physics_mesh->faces.size();

  thrust::host_vector<Vector3> h_positions = physics_mesh->HostPositions();
  thrust::host_vector<uint> h_indices = physics_mesh->HostIndices();

  for (size_t i = 0; i < num_vertices; i++) {
    Vector3 pos = h_positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << h_indices[i * 3] + 1 << " " << h_indices[i * 3 + 1] + 1 << " "
        << h_indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

void SaveGarmentAsObj(const std::string& path, Vector3* positions, unsigned int* indices,
                      const unsigned int num_vertices, const unsigned int num_triangles) {
  std::cout << "Save garment obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o garment\n";
  for (size_t i = 0; i < num_vertices; i++) {
    Vector3 pos = positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << indices[i * 3] + 1 << " " << indices[i * 3 + 1] + 1 << " "
        << indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

void SaveMeshAsObj(const std::string& path, const std::vector<Vector3>& positions,
                   const std::vector<unsigned int>& indices) {
  const unsigned int num_vertices = positions.size();
  const unsigned int num_triangles = indices.size() / 3;

  std::cout << "Save garment obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o garment\n";
  for (size_t i = 0; i < num_vertices; i++) {
    Vector3 pos = positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << indices[i * 3] + 1 << " " << indices[i * 3 + 1] + 1 << " "
        << indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

void SaveGarmentAsObj(const std::string& path, Vector3* positions, Vector3* colors,
                      unsigned int* indices, const unsigned int num_vertices,
                      const unsigned int num_triangles) {
  std::cout << "Save garment obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o garment\n";
  for (size_t i = 0; i < num_vertices; i++) {
    Vector3 pos = positions[i];
    Vector3 color = colors[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << " " << color.x << " " << color.y << " "
        << color.z << "\n";
  }
  ofs << "s 1\n";

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << indices[i * 3] + 1 << " " << indices[i * 3 + 1] + 1 << " "
        << indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

void SaveMeshDataAsObj(const std::string& path, const MeshData& mesh_data) {
  std::cout << "Save garment obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o garment\n";

  auto verts = mesh_data.positions;
  auto uvs = mesh_data.uvs;
  auto normals = mesh_data.normals;
  auto indices = mesh_data.indices;
  for (size_t i = 0; i < verts.size(); i++) {
    Vector3 pos = verts[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  ofs << "s 1\n";
  int n_faces = indices.size();
  for (int i = 0; i < n_faces; i++) {
    ofs << "f " << indices[i][0].position + 1 << " " << indices[i][1].position + 1 << " "
        << indices[i][2].position + 1 << "\n";
  }
  ofs.close();
}

void SaveMeshDataAsObjWithUVNormal(const std::string& path, const MeshData& mesh_data) {
  std::cout << "Save garment obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by Tailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o garment\n";

  auto verts = mesh_data.positions;
  auto uvs = mesh_data.uvs;
  auto normals = mesh_data.normals;
  auto indices = mesh_data.indices;
  for (size_t i = 0; i < verts.size(); i++) {
    Vector3 pos = verts[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }
  for (size_t i = 0; i < uvs.size(); i++) {
    Vector3 uv = uvs[i];
    ofs << "vt " << uv.x << " " << uv.y << "\n";
  }
  for (size_t i = 0; i < normals.size(); i++) {
    Vector3 normal = normals[i];
    ofs << "vn " << normal.x << " " << normal.y << " " << normal.z << "\n";
  }
  ofs << "s 1\n";
  int n_faces = indices.size();
  for (int i = 0; i < n_faces; i++) {
    ofs << "f " << indices[i][0].position + 1 << "/" << indices[i][0].uv + 1 << "/"
        << indices[i][0].normal + 1 << " " << indices[i][1].position + 1 << "/"
        << indices[i][1].uv + 1 << "/" << indices[i][1].normal + 1 << " "
        << indices[i][2].position + 1 << "/" << indices[i][1].uv + 1 << "/"
        << indices[i][1].normal + 1 << "\n";
  }
  ofs.close();
}

Scalar MapValue(Scalar val, Scalar target_min, Scalar target_max, Scalar data_min,
                Scalar data_max) {

  if (val < data_min) {
    val = data_min;
  }
  if (val > data_max) {
    val = data_max;
  }

  // Map value
  return target_min + ((val - data_min) / (data_max - data_min)) * (target_max - target_min);
}

Vector3 Hsv2rgb(Vector3 in) {

  double h, p, q, t, f;
  long i;
  Vector3 out;

  h = in[0] * 360;
  if (h >= 360) {
    h = 0;
  }
  h /= 60;
  i = static_cast<long>(h);
  f = h - i;
  p = in[2] * (1 - in[1]);
  q = in[2] * (1 - (in[1] * f));
  t = in[2] * (1 - (in[1] * (1 - f)));

  switch (i) {
    case 0:
      out[0] = in[2];
      out[1] = t;
      out[2] = p;
      break;

    case 1:
      out[0] = q;
      out[1] = in[2];
      out[2] = p;
      break;

    case 2:
      out[0] = p;
      out[1] = in[2];
      out[2] = t;
      break;

    case 3:
      out[0] = p;
      out[1] = q;
      out[2] = in[2];
      break;

    case 4:
      out[0] = t;
      out[1] = p;
      out[2] = in[2];
      break;

    case 5:
    default:
      out[0] = in[2];
      out[1] = p;
      out[2] = q;
      break;
  }

  return out;
}

std::string GetBasename(std::string str) {

  // Find position of extension separator
  std::string::size_type pos;
  pos = str.find(".");
  // If separator not found, return the entire string
  if (pos == std::string::npos) {
    return str;
  }
  // Return substring from the beginning until the separator
  return str.substr(0, pos);
}

std::string NumToStr(int num) {

  std::ostringstream ss;
  ss << num;
  return ss.str();
}

template void SaveBodyAsObj(const std::string& path,
                            std::shared_ptr<smplx::Body<smplx::model_config::SMPL>> body,
                            Vector3* h_positions);
template void SaveBodyAsObj(const std::string& path,
                            std::shared_ptr<smplx::Body<smplx::model_config::SMPLH>> body,
                            Vector3* h_positions);
template void SaveBodyAsObj(const std::string& path,
                            std::shared_ptr<smplx::Body<smplx::model_config::SMPLX>> body,
                            Vector3* h_positions);

template void SaveBodyAsObj(const std::string& path,
                            std::shared_ptr<smplx::Body<smplx::model_config::SMPL>> body,
                            std::shared_ptr<PhysicsMesh> physicsMesh);
template void SaveBodyAsObj(const std::string& path,
                            std::shared_ptr<smplx::Body<smplx::model_config::SMPLH>> body,
                            std::shared_ptr<PhysicsMesh> physicsMesh);
template void SaveBodyAsObj(const std::string& path,
                            std::shared_ptr<smplx::Body<smplx::model_config::SMPLX>> body,
                            std::shared_ptr<PhysicsMesh> physicsMesh);
}  // namespace XRTailor
