#include <xrtailor/runtime/export/ObjSequenceExporter.hpp>

#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#if defined(_WIN64) || defined(WIN32) || defined(_WIN32)
#include <direct.h>
#else
#include <sys/stat.h>
#endif

#include "glm/glm.hpp"

#include <xrtailor/utils/Logger.hpp>

#define PBSTR "||||||||||||||||||||"
#define PBWIDTH 20

namespace XRTailor {
void SaveObj(const std::string& path, const Vector3* positions, const Vector3* normals, const unsigned int* indices,
             const unsigned int& num_vertices, const unsigned int& num_triangles,
             const unsigned int& index_offset) {
  //std::cout << "Save obj" << std::endl;
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o mesh\n";
  for (size_t i = index_offset; i < num_vertices + index_offset; i++) {
    Vector3 pos = positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }

  for (size_t i = index_offset; i < num_vertices + index_offset; i++) {
    Vector3 normal = normals[i];
    ofs << "vn " << normal.x << " " << normal.y << " " << normal.z << "\n";
  }

  ofs << "s 1\n";

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << indices[i * 3] + 1 << " " << indices[i * 3 + 1] + 1 << " "
        << indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

void SaveObj(const std::string& path, const Vector3* positions, const Vector3* normals,
             const std::vector<Vector2>& uvs, const unsigned int* indices, const unsigned int* normal_indices,
             const unsigned int* uv_indices, const unsigned int& num_vertices,
             const unsigned int& num_triangles, unsigned int& index_offset) {
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o mesh\n";
  for (size_t i = index_offset; i < num_vertices + index_offset; i++) {
    Vector3 pos = positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }

  for (size_t i = 0; i < uvs.size(); i++) {
    Vector2 uv = uvs[i];
    ofs << "vt " << uv.x << " " << uv.y << " "
        << "\n";
  }

  for (size_t i = index_offset; i < num_vertices + index_offset; i++) {
    Vector3 normal = normals[i];
    ofs << "vn " << normal.x << " " << normal.y << " " << normal.z << "\n";
  }

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << indices[i * 3] + 1 << "/" << uv_indices[i * 3] + 1 << "/"
        << normal_indices[i * 3] + 1 << " " << indices[i * 3 + 1] + 1 << "/"
        << uv_indices[i * 3 + 1] + 1 << "/" << normal_indices[i * 3 + 1] + 1 << " "
        << indices[i * 3 + 2] + 1 << "/" << uv_indices[i * 3 + 2] + 1 << "/"
        << normal_indices[i * 3 + 2] + 1 << " "
        << "\n";
  }
  ofs.close();
}

void SaveObj(const std::string& path, const Vector3* positions, const unsigned int* indices,
             const unsigned int& num_vertices, const unsigned int& num_triangles,
             const unsigned int& index_offset) {
  std::ofstream ofs(path);
  ofs << "# Generated by XRTailor"
      << "\n";
  ofs << std::fixed << std::setprecision(6) << "o mesh\n";
  for (size_t i = index_offset; i < num_vertices + index_offset; i++) {
    Vector3 pos = positions[i];
    ofs << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
  }

  ofs << "s 1\n";

  for (int i = 0; i < num_triangles; i++) {
    ofs << "f " << indices[i * 3] + 1 << " " << indices[i * 3 + 1] + 1 << " "
        << indices[i * 3 + 2] + 1 << "\n";
  }
  ofs.close();
}

std::string FormatInt(int n, int number_of_leading_zeros = 0) {
  std::ostringstream s;
  s << std::setw(number_of_leading_zeros) << std::setfill('0') << n;
  return s.str();
}

void ObjSequenceExporter::ExportFrame(filesystem::path export_path, std::string export_filename,
                                      std::shared_ptr<Mesh> mesh, unsigned int frame_index,
                                      std::string prefix,
                                      std::shared_ptr<std::vector<Vector3*>> positions_cache,
                                      std::shared_ptr<std::vector<Vector3*>> normals_cache,
                                      unsigned int index_offset) {
  const unsigned int* indices = mesh->Indices().data();

  const unsigned int* normal_indices = mesh->NormalIndices().data();
  const unsigned int* uv_indices = mesh->UVIndices().data();

  const std::vector<Vector2>& uvs = mesh->UVs();

  size_t num_indices = mesh->Indices().size();
  size_t num_faces = num_indices / 3;
  size_t num_verts = mesh->Positions().size();
  size_t num_frames = positions_cache->size();

  if (frame_index >= num_frames) {
    LOG_ERROR("Out of range: sequence has {} frames but attempted to access frame {}", num_frames,
              frame_index);
    exit(TAILOR_EXIT::FRAME_OUT_OF_RANGE);
  }

  if (!filesystem::exists(export_path)) {
    try {
      filesystem::create_directory(export_path);
    } catch (filesystem::filesystem_error e) {
      LOG_ERROR("{}", e.what());
      exit(TAILOR_EXIT::CREATE_DIRECTORY_ERROR);
    }
  }

  filesystem::path full_path(export_path);
  full_path.append(export_filename);

  Vector3* verts = (*positions_cache)[frame_index];
  Vector3* normals = (*normals_cache)[frame_index];

  SaveObj(full_path.string(), verts, normals, uvs, indices, normal_indices, uv_indices, num_verts,
          num_faces, index_offset);

  LOG_INFO("Obj exported to {}", full_path.string());
}

void ObjSequenceExporter::ExportObjSequence(filesystem::path export_path,
                                            std::shared_ptr<Mesh> mesh,
                                            std::shared_ptr<std::vector<Vector3*>> positions_cache,
                                            std::shared_ptr<std::vector<Vector3*>> normals_cache,
                                            unsigned int index_offset) {
  const unsigned int* indices = mesh->Indices().data();
  const unsigned int* normal_indices = mesh->NormalIndices().data();
  const unsigned int* uv_indices = mesh->UVIndices().data();

  const std::vector<Vector2>& uvs = mesh->UVs();

  size_t num_indices = mesh->Indices().size();
  size_t num_faces = num_indices / 3;
  size_t num_verts = mesh->Positions().size();
  size_t num_frames = positions_cache->size();

  if (!filesystem::exists(export_path)) {
    try {
      filesystem::create_directory(export_path);
    } catch (filesystem::filesystem_error e) {
      LOG_ERROR("{}", e.what());
      exit(TAILOR_EXIT::CREATE_DIRECTORY_ERROR);
    }
  }

  LOG_INFO("Sequence has {} frames, target save path: {}", num_frames, export_path.string().c_str());

  Scalar percentage = 0;
  int val = 0, lpad = 0, rpad = 0;

  for (size_t frame = 0; frame < num_frames; frame++) {
    std::string file_name(FormatInt(frame, 6) + ".obj");
    filesystem::path full_path(export_path);
    full_path.append(file_name);

    percentage = static_cast<Scalar>(frame + 1) / num_frames;
    val = static_cast<int>(percentage * 100);
    lpad = static_cast<int>(percentage * PBWIDTH);
    rpad = PBWIDTH - lpad;

    Vector3* verts = (*positions_cache)[frame];
    Vector3* normals = (*normals_cache)[frame];
    SaveObj(full_path.string(), verts, normals, uvs, indices, normal_indices, uv_indices, num_verts,
            num_faces, index_offset);

    printf("\rExport %s %d/%d [%.*s%*s] %3d%%", file_name.c_str(), static_cast<int>(frame + 1),
           static_cast<int>(num_frames), lpad, PBSTR, rpad, "", val);
    fflush(stdout);
  }
  printf("\n");
}

void ObjSequenceExporter::ExportObjSequence(filesystem::path export_path,
                                            std::shared_ptr<Mesh> mesh,
                                            std::shared_ptr<std::vector<Vector3*>> positions_cache,
                                            unsigned int index_offset) {
  const unsigned int* indices = mesh->Indices().data();
  size_t num_indices = mesh->Indices().size();
  size_t num_faces = num_indices / 3;
  size_t num_verts = mesh->Positions().size();
  size_t num_frames = positions_cache->size();

  if (!filesystem::exists(export_path)) {
    try {
      filesystem::create_directory(export_path);
    } catch (filesystem::filesystem_error e) {
      LOG_ERROR("{}", e.what());
      exit(TAILOR_EXIT::CREATE_DIRECTORY_ERROR);
    }
  }

  LOG_INFO("Sequence has {} frames, target save path: {}", num_frames, export_path.string().c_str());

  Scalar percentage = 0.0f;
  int val = 0, lpad = 0, rpad = 0;

  for (size_t frame = 0; frame < num_frames; frame++) {

    std::string file_name(FormatInt(frame, 6) + ".obj");
    filesystem::path full_path(export_path);
    full_path.append(file_name);

    percentage = static_cast<Scalar>(frame + 1) / num_frames;
    val = static_cast<int>(percentage * 100);
    lpad = static_cast<int>(percentage * PBWIDTH);
    rpad = PBWIDTH - lpad;

    const Vector3* verts = (*positions_cache)[frame];
    SaveObj(full_path.string(), verts, indices, num_verts, num_faces, index_offset);

    printf("\rExport %s %d/%d [%.*s%*s] %3d%%", file_name.c_str(), static_cast<int>(frame + 1),
           static_cast<int>(num_frames), lpad, PBSTR, rpad, "", val);
    fflush(stdout);
  }
  printf("\n");
}
}  // namespace XRTailor